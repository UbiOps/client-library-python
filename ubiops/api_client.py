# coding: utf-8

"""
    UbiOps

    Client Library to interact with the UbiOps API.

    The version of the OpenAPI document: v2.1
    Generated by: https://openapi-generator.tech
"""


import atexit
import datetime
import json
import mimetypes
import os
import re
import tempfile
import tqdm
import types
import urllib.parse

from dateutil.parser import parse
from multiprocessing.pool import ThreadPool

from ubiops.configuration import Configuration
import ubiops.models
from ubiops import rest
from ubiops.exceptions import ApiValueError


class ApiClient(object):
    """
    Custom ApiClient for OpenAPI client library builds. This client handles the client-server communication.

    NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech
    Do not edit the class manually.

    :param configuration: configuration object for this client
    :param header_name: a header to pass when making calls to the API
    :param header_value: a header value to pass when making calls to the API
    :param cookie: a cookie to include in the header when making calls to the API
    :param pool_threads: The number of threads to use for async requests to the API. More threads means more concurrent
        API requests.
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        "int": int,
        "long": int,
        "float": float,
        "str": str,
        "bool": bool,
        "date": datetime.date,
        "datetime": datetime.datetime,
        "object": object,
    }
    _pool = None

    def __init__(self, configuration=None, header_name=None, header_value=None, cookie=None, pool_threads=1):
        if configuration is None:
            configuration = Configuration()
        self.configuration = configuration
        self.pool_threads = pool_threads

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value

        self.cookie = cookie
        self.user_agent = "UbiOps/python/4.2.0"
        self.client_side_validation = configuration.client_side_validation

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def __del__(self):
        self.close()

    def close(self):
        """
        Close the ThreadPool if initialized
        """

        if self._pool:
            self._pool.close()
            self._pool.join()
            self._pool = None
            if hasattr(atexit, "unregister"):
                atexit.unregister(self.close)

    @property
    def pool(self):
        """
        Create thread pool on first request avoids instantiating unused threadpool for blocking clients
        """

        if self._pool is None:
            atexit.register(self.close)
            self._pool = ThreadPool(self.pool_threads)
        return self._pool

    @property
    def user_agent(self):
        """
        User agent for this API client
        """

        return self.default_headers["User-Agent"]

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers["User-Agent"] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value

    def sanitize_for_serialization(self, obj):
        """
        Builds a JSON POST object.

        If obj is None; return None.
        If obj is str, int, float, bool; return directly.
        If obj is datetime.datetime, datetime.date; convert to string in iso8601 format.
        If obj is list; sanitize each element in the list.
        If obj is dict; return the dict.
        If obj is OpenAPI model; return the properties.

        :param obj: the data to serialize
        :return: the serialized form of data
        """

        if obj is None:
            return None
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
        elif isinstance(obj, tuple):
            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        if isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except attributes `openapi_types`, `attribute_map` and attributes which value
            # is not None. Convert attribute name to json key in model definition for request.
            obj_dict = {
                obj.attribute_map[attr]: getattr(obj, attr)
                for attr, _ in obj.openapi_types.items()
                if getattr(obj, attr) is not None
            }

        return {key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()}

    def deserialize(self, response, response_type, stream=False, chunk_size=8192, progress_bar=False):
        """
        Deserializes response into an object

        :param response: RESTResponse object to be deserialized
        :param response_type: class literal for deserialized object, or string of class name
        :param bool stream: only used to stream files
        :param int chunk_size: if streaming enabled, the size for each chunk
        :param bool progress_bar: if response type is file, whether to show a progress bar when downloading

        :return: deserialized object
        """

        # Handle file downloading; save response body into a tmp file and return the instance
        if response_type == "file":
            return self.__deserialize_file(response, stream=stream, chunk_size=chunk_size, progress_bar=progress_bar)

        # Fetch data from response object
        try:
            data = json.loads(response.text)
        except ValueError:
            data = response.text

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """
        Deserializes dict, list, str into an object

        :param data: dict, list or str
        :param klass: class literal, or string of class name

        :return: object
        """

        if data is None:
            return None

        if type(klass) == str:
            if klass.startswith("list["):
                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]

            if klass.startswith("dict("):
                sub_kls = re.match(r"dict\(([^,]*), (.*)\)", klass).group(2)
                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}

            # Convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(ubiops.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        else:
            return self.__deserialize_model(data, klass)

    def call_api(
        self,
        resource_path,
        method,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None,
        response_type=None,
        auth_settings=None,
        async_req=None,
        _return_http_data_only=None,
        collection_formats=None,
        _preload_content=True,
        _request_timeout=None,
        _host=None,
        stream=False,
        chunk_size=8192,
        progress_bar=False,
    ):
        """
        Makes the HTTP request (synchronous) and returns deserialized data.
        To make an async_req request, set the async_req parameter.

        :param resource_path: path to method endpoint
        :param method: method to call
        :param path_params: path parameters in the url
        :param query_params: query parameters in the url
        :param header_params: header parameters to be placed in the request header
        :param body: request body
        :param list|dict post_params: request post form parameters, for `application/x-www-form-urlencoded`,
            `multipart/form-data`
        :param list auth_settings: auth Settings names for the request
        :param response_type: response data type
        :param list|dict files: key -> filename, value -> filepath, for `multipart/form-data`
        :param bool async_req: execute request asynchronously
        :param _return_http_data_only: response data without head status code and headers
        :param collection_formats: dict of collection formats for path, query, header, and post parameters
        :param _preload_content: if False, the requests.Response object will be returned without reading/decoding
            response data. Default is True.
        :param _request_timeout: timeout setting for this request. If one number provided, it will be total request
            timeout. It can also be a pair (tuple) of (connection, read) timeouts.
        :param _host: server/host defined in path
        :param stream: whether to use streaming
        :param chunk_size: the size for each chunk, only used when streaming file output to a temporary file
        :param bool progress_bar: whether to show a TQDM progress bar
        :return:
            If async_req parameter is True, the request will be called asynchronously. The method will return the
            request thread.
            If parameter async_req is False or missing, then the method will return the response directly.
        """

        if not async_req:
            return self.__call_api(
                resource_path,
                method,
                path_params,
                query_params,
                header_params,
                body,
                post_params,
                files,
                response_type,
                auth_settings,
                _return_http_data_only,
                collection_formats,
                _preload_content,
                _request_timeout,
                _host,
                stream,
                chunk_size,
                progress_bar,
            )

        return self.pool.apply_async(
            self.__call_api,
            (
                resource_path,
                method,
                path_params,
                query_params,
                header_params,
                body,
                post_params,
                files,
                response_type,
                auth_settings,
                _return_http_data_only,
                collection_formats,
                _preload_content,
                _request_timeout,
                _host,
                stream,
                chunk_size,
                progress_bar,
            ),
        )

    def __call_api(
        self,
        resource_path,
        method,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None,
        response_type=None,
        auth_settings=None,
        _return_http_data_only=None,
        collection_formats=None,
        _preload_content=True,
        _request_timeout=None,
        _host=None,
        stream=False,
        chunk_size=8192,
        progress_bar=False,
    ):
        config = self.configuration

        # Header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params["Cookie"] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(self.parameters_to_tuples(header_params, collection_formats))
            # Make sure all header values are strings
            header_params = {k: str(v) for k, v in header_params.items()}

        # Path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(path_params, collection_formats)
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    "{%s}" % k, urllib.parse.quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # Query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            query_params = self.parameters_to_tuples(query_params, collection_formats)

        # Post parameters / files
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(post_params, collection_formats)
            post_params = [(k, str(v) if isinstance(v, bool) else v) for k, v in post_params]
            post_params.extend(self.files_parameters(files))

        # Auth setting
        self.update_params_for_auth(header_params, query_params, auth_settings)

        # Body
        if body:
            body = self.sanitize_for_serialization(body)

        # Request url
        if _host is None:
            _host = self.configuration.host

        # Perform request and return response
        response_data = self.rest_client.request(
            method=method,
            host=_host,
            resource_path=resource_path,
            query_params=query_params,
            headers=header_params,
            post_params=post_params,
            body=body,
            stream=stream,
            _request_timeout=_request_timeout,
            progress_bar=progress_bar,
        )

        self.last_response = response_data

        return_data = response_data
        if _preload_content:
            # Deserialize response data
            if response_type:
                return_data = self.deserialize(
                    response_data, response_type, stream=stream, chunk_size=chunk_size, progress_bar=progress_bar
                )
            else:
                return_data = None
        elif response_type == "file":
            return_data.getfilename = types.MethodType(getfilename, return_data)
            return_data.read = types.MethodType(read, return_data)

        if _return_http_data_only:
            return return_data
        else:
            return return_data, response_data.status_code, response_data.headers

    @staticmethod
    def parameters_to_tuples(params, collection_formats):
        """
        Get parameters as list of tuples, formatting collections

        :param params: parameters as dict or list of two-tuples
        :param dict collection_formats: parameter collection formats
        :return: parameters as list of tuples, collections formatted
        """

        new_params = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == "multi":
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == "ssv":
                        delimiter = " "
                    elif collection_format == "tsv":
                        delimiter = "\t"
                    elif collection_format == "pipes":
                        delimiter = "|"
                    else:  # Csv is the default
                        delimiter = ","
                    new_params.append((k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    @staticmethod
    def files_parameters(files=None):
        """
        Builds form parameters

        :param files: file parameters
        :return: form parameters with files
        """

        params = []

        if files:
            for k, v in files.items():
                if not v:
                    continue
                file_names = v if type(v) is list else [v]
                for n in file_names:
                    filename = os.path.basename(n)
                    mimetype = mimetypes.guess_type(filename)[0] or "application/octet-stream"
                    params.append(tuple([k, tuple([filename, open(n, "rb"), mimetype])]))

        return params

    @staticmethod
    def select_header_accept(accepts):
        """
        Returns `Accept` based on an array of accepts provided

        :param accepts: list of headers
        :return: Accept (e.g. application/json)
        """

        if not accepts:
            return

        accepts = [x.lower() for x in accepts]

        if "application/json" in accepts:
            return "application/json"
        else:
            return ", ".join(accepts)

    @staticmethod
    def select_header_content_type(content_types):
        """
        Returns `Content-Type` based on an array of content_types provided

        :param content_types: list of content-types
        :return: Content-Type (e.g. application/json)
        """

        if not content_types:
            return "application/json"

        content_types = [x.lower() for x in content_types]

        if "application/json" in content_types or "*/*" in content_types:
            return "application/json"
        else:
            return content_types[0]

    def update_params_for_auth(self, headers, query_params, auth_settings):
        """
        Updates header and query params based on authentication setting

        :param headers: header parameters dict to be updated
        :param query_params: query parameters tuple list to be updated
        :param auth_settings: authentication setting identifiers list
        """

        if not auth_settings:
            return

        for auth in auth_settings:
            auth_setting = self.configuration.auth_settings().get(auth)
            if auth_setting:
                if auth_setting["in"] == "cookie":
                    headers["Cookie"] = auth_setting["value"]
                elif auth_setting["in"] == "header":
                    headers[auth_setting["key"]] = auth_setting["value"]
                elif auth_setting["in"] == "query":
                    query_params.append((auth_setting["key"], auth_setting["value"]))
                else:
                    raise ApiValueError("Authentication token must be in `query` or `header`")

    def __deserialize_file(self, response, stream=True, chunk_size=8192, progress_bar=False):
        """
        Deserializes body to file and saves response body into a file in a temporary folder, using the filename from
         the `Content-Disposition` header if provided

        :param response:  RESTResponse
        :param bool stream: whether to download the file streaming or not
        :param int chunk_size: if streaming enabled, the size for each chunk
        :param bool progress_bar: whether to show a TQDM progress bar
        :return: file path
        """

        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.headers.get("Content-Disposition", None)
        if content_disposition:
            # Remove quotes added by the API
            decoded_content_disposition = urllib.parse.unquote(content_disposition)
            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?', decoded_content_disposition).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as filestream:
            if not stream:
                filestream.write(response.content)

            elif progress_bar:
                with tqdm.tqdm(
                    unit="B",
                    unit_scale=True,
                    unit_divisor=1024,
                    miniters=1,
                    desc="Downloading",
                    total=int(response.headers.get("Content-Length", 0)),
                ) as bar:
                    for chunk in response.iter_content(chunk_size=chunk_size):
                        filestream.write(chunk)
                        bar.update(len(chunk))

            else:
                for chunk in response.iter_content(chunk_size=chunk_size):
                    filestream.write(chunk)

        return path

    @staticmethod
    def __deserialize_primitive(data, klass):
        """
        Deserializes string to primitive type

        :param data: str
        :param klass: class literal

        :return: int, float, str, bool
        """

        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    @staticmethod
    def __deserialize_object(value):
        """
        Return an original value

        :return: object
        """

        return value

    @staticmethod
    def __deserialize_date(string):
        """
        Deserializes string to date

        :param string: str
        :return: date
        """

        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(status=0, reason=f"Failed to parse `{string}` as date object")

    @staticmethod
    def __deserialize_datetime(string):
        """
        Deserializes string to datetime. The string should be in iso8601 datetime format.

        :param string: str
        :return: datetime
        """

        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(status=0, reason=f"Failed to parse `{string}` as datetime object")

    def __deserialize_model(self, data, klass):
        """
        Deserializes list or dict to model

        :param data: dict, list
        :param klass: class literal
        :return: model object
        """

        if not klass.openapi_types and not hasattr(klass, "get_real_child_model"):
            return data

        kwargs = {}
        if data is not None and klass.openapi_types is not None and isinstance(data, (list, dict)):
            for attr, attr_type in klass.openapi_types.items():
                if klass.attribute_map[attr] in data:
                    value = data[klass.attribute_map[attr]]
                    kwargs[attr] = self.__deserialize(value, attr_type)

        if "local_vars_configuration" not in kwargs:
            kwargs["local_vars_configuration"] = self.configuration
        instance = klass(**kwargs)

        if hasattr(instance, "get_real_child_model"):
            klass_name = instance.get_real_child_model(data)
            if klass_name:
                instance = self.__deserialize(data, klass_name)
        return instance


def getfilename(self):
    """
    Get the filename from the Content-Disposition header
    """

    content_disposition = self.headers.get("Content-Disposition")
    if content_disposition:
        # Remove quotes added by the API
        decoded_content_disposition = urllib.parse.unquote(content_disposition)
        return re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?', decoded_content_disposition).group(1)


def read(self, chunk_size=None):
    """
    Retrieve the response content
    """

    if chunk_size:
        return self.iter_content(chunk_size=chunk_size)
    return self.content
