# coding: utf-8

"""
    UbiOps

    Client Library to interact with the UbiOps API.

    The version of the OpenAPI document: v2.1
    Generated by: https://openapi-generator.tech
"""


import certifi
import logging
import re
import requests
import requests_toolbelt
import time
import tqdm
import urllib.parse

from contextlib import nullcontext
from requests_toolbelt.adapters.socket_options import TCPKeepAliveAdapter

from ubiops.exceptions import ApiConnectionError, ApiException, ApiRequestError, ApiTimeoutError, ApiValueError


logger = logging.getLogger(__name__)


class RESTClientObject(object):
    def __init__(self, configuration):
        """
        Initialize the Requests Session object

        :param configuration: configuration object for this client
        """

        # https://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification
        if configuration.verify_ssl:
            if configuration.ssl_ca_cert:
                self.verify = configuration.ssl_ca_cert
            else:
                self.verify = certifi.where()
        else:
            self.verify = False

        # https://docs.python-requests.org/en/latest/user/advanced/#client-side-certificates
        self.cert = None
        if configuration.cert_file and configuration.key_file:
            self.cert = (configuration.cert_file, configuration.key_file)
        elif configuration.cert_file:
            self.cert = configuration.cert_file

        self.auto_retry_rate_limiting = configuration.auto_retry_rate_limiting

    @staticmethod
    def close_files(post_params):
        """
        Close the opened files in the post parameters
        """

        for k, v in post_params:
            if isinstance(v, tuple) and len(v) == 3:
                try:
                    v[1].close()
                except (TypeError, IndexError, AttributeError):
                    pass

    def request(
        self,
        method,
        host,
        resource_path,
        query_params=None,
        headers=None,
        body=None,
        post_params=None,
        stream=False,
        _request_timeout=None,
        progress_bar=False,
    ):
        """
        Perform request

        :param method: http request method
        :param host: base url
        :param resource_path: path to method endpoint
        :param query_params: query parameters in the url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters, `application/x-www-form-urlencoded` and `multipart/form-data`
        :param bool stream: whether to use streaming or not
        :param _request_timeout: timeout setting for this request. If one number provided, it will be total request
            timeout. It can also be a pair (tuple) of (connection, read) timeouts.
        :param bool progress_bar: whether to show a progress bar for uploading files
        """

        method = method.upper()
        assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]

        if post_params and body:
            raise ApiValueError("body parameter cannot be used with post_params parameter")

        post_params = post_params or {}
        headers = headers or {}

        if "Content-Type" not in headers:
            headers["Content-Type"] = "application/json"

        params = {
            "method": method,
            "url": host + resource_path,
            "stream": stream,
            "timeout": _request_timeout,
            "headers": headers,
            "cert": self.cert,
            "verify": self.verify,
        }

        with requests.Session() as session:
            # Allow for long running requests (>600s GCP, >350s AWS) using the TCPKeepAliveAdapter
            session.mount(host, TCPKeepAliveAdapter())

            try:
                if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
                    if query_params:
                        params["url"] += "?" + urllib.parse.urlencode(query_params)

                    if re.search("json", headers["Content-Type"], re.IGNORECASE):
                        r = session.request(**params, json=body)

                    elif headers["Content-Type"] in ["multipart/form-data", "application/x-www-form-urlencoded"]:
                        encoder = requests_toolbelt.MultipartEncoder(fields=dict(post_params))

                        if progress_bar:
                            cm = tqdm.tqdm(
                                unit="B",
                                unit_scale=True,
                                unit_divisor=1024,
                                miniters=1,
                                desc="Uploading",
                                total=encoder.len,
                            )
                        else:
                            cm = nullcontext()

                        with cm as bar:
                            if bar:
                                encoder = requests_toolbelt.MultipartEncoderMonitor(
                                    encoder, lambda monitor: bar.update(monitor.bytes_read - bar.n)
                                )

                            try:
                                params["headers"]["Content-Type"] = encoder.content_type
                                r = session.request(**params, data=encoder)

                            except Exception:
                                self.close_files(post_params)
                                raise

                            self.close_files(post_params)

                    # Pass a `string` parameter directly in the body to support other content types than Json when
                    # `body` argument is provided in serialized form
                    elif isinstance(body, str) or isinstance(body, bytes):
                        r = session.request(**params, data=body)

                    else:
                        # Cannot generate the request from given parameters
                        raise ApiException(
                            status=0,
                            reason="Cannot prepare a request message for provided arguments. Please check that your"
                            " arguments match declared content type.",
                        )

                # For `GET`, `HEAD`
                else:
                    r = session.request(**params, params=query_params)

            except requests.exceptions.ConnectionError as e:
                raise ApiConnectionError(status=0, reason=f"{type(e).__name__}\n{e}")

            except requests.exceptions.Timeout as e:
                raise ApiTimeoutError(status=0, reason=f"{type(e).__name__}\n{e}")

            except requests.exceptions.RequestException as e:
                raise ApiRequestError(status=0, reason=f"{type(e).__name__}\n{e}")

            if not stream:
                logger.debug(f"Response body: {r.text}")

            if r.status_code == 429 and self.auto_retry_rate_limiting:
                # Add 1 extra second to be sure in case reset time was rounded down
                reset_time = int(r.headers.get("x-ratelimit-reset", 59)) + 1
                logger.error(f"Rate Limit Exceeded. Automatic retry in {reset_time} seconds.")
                time.sleep(reset_time)
                return self.request(
                    method=method,
                    host=host,
                    resource_path=resource_path,
                    query_params=query_params,
                    headers=headers,
                    body=body,
                    post_params=post_params,
                    stream=stream,
                    _request_timeout=_request_timeout,
                    progress_bar=progress_bar,
                )

            if not 200 <= r.status_code <= 299:
                raise ApiRequestError(requests_resp=r)

            return r
